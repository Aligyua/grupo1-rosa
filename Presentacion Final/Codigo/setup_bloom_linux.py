#!/usr/bin/env python3
"""
BLOOM MUSIC V2 - INSTALADOR PARA LINUX (Con BD Persistente)
============================================================
Compatible con Python 3.13+ y PEP 668

NUEVAS CARACTER√çSTICAS:
- ‚úÖ Base de datos persistente (no se pierde al reinstalar)
- ‚úÖ Detecta e importa BD existente autom√°ticamente
- ‚úÖ Sistema modular de navegaci√≥n
- ‚úÖ Editar perfil integrado

REQUISITOS:
- Python 3.8+
- python3-venv, python3-full
- Conexi√≥n a internet
"""

import subprocess
import sys
import os
import shutil

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
os.chdir(SCRIPT_DIR)

VENV_DIR = os.path.join(SCRIPT_DIR, "venv_bloom")
VENV_PYTHON = os.path.join(VENV_DIR, "bin", "python")

print(f"üìÇ Trabajando en: {SCRIPT_DIR}\n")

def print_header(text):
    print("\n" + "="*60)
    print(f"  {text}")
    print("="*60 + "\n")

def check_python_version():
    print_header("VERIFICANDO VERSI√ìN DE PYTHON")
    version = sys.version_info
    print(f"Python {version.major}.{version.minor}.{version.micro} detectado")
    
    if version.major < 3 or (version.major == 3 and version.minor < 8):
        print("‚ùå ERROR: Se requiere Python 3.8+")
        print("   sudo apt install python3 python3-pip python3-venv")
        return False
    
    if version.major == 3 and version.minor >= 13:
        print(f"‚ÑπÔ∏è  Python {version.major}.{version.minor} - Usar√° entorno virtual (PEP 668)")
    
    print("‚úÖ Versi√≥n correcta")
    return True

def check_venv_support():
    print_header("VERIFICANDO SOPORTE DE ENTORNO VIRTUAL")
    try:
        import venv
        print("‚úÖ M√≥dulo venv disponible")
        return True
    except ImportError:
        print("‚ùå M√≥dulo venv no encontrado")
        print("\nüí° Inst√°lalo:")
        print("   sudo apt install python3-venv python3-full")
        return False

def buscar_bd_existente():
    """Busca una base de datos existente"""
    print_header("BUSCANDO BASE DE DATOS EXISTENTE")
    
    bd_local = os.path.join(SCRIPT_DIR, "Database_Bloom_Music.db")
    
    if os.path.exists(bd_local):
        size = os.path.getsize(bd_local) / 1024
        print(f"‚úÖ Base de datos encontrada!")
        print(f"   üìÅ {bd_local}")
        print(f"   üíæ Tama√±o: {size:.2f} KB")
        
        print("\nüí° La nueva versi√≥n guarda la BD en:")
        print("   ~/.config/BloomMusic/database/")
        
        print("\nüìã Beneficios:")
        print("   ‚úÖ Tu cuenta NO se pierde al reinstalar")
        print("   ‚úÖ BD protegida en ubicaci√≥n del sistema")
        
        respuesta = input("\n¬øUsar esta base de datos? (s/n): ")
        
        if respuesta.lower() in ['s', 'si', 'y', 'yes']:
            print("‚úÖ Se importar√° autom√°ticamente")
            return bd_local
        else:
            print("‚ö†Ô∏è  Se crear√° una nueva BD")
            return None
    else:
        print("‚ÑπÔ∏è  No se encontr√≥ BD existente")
        print("   Se crear√° una nueva en ubicaci√≥n persistente")
        return None

def create_virtual_environment():
    print_header("CREANDO ENTORNO VIRTUAL")
    
    if os.path.exists(VENV_DIR):
        print(f"‚ÑπÔ∏è  Entorno virtual existe: {VENV_DIR}")
        response = input("¬øRecrearlo? (s/n): ")
        if response.lower() in ['s', 'si', 'y', 'yes']:
            print("üóëÔ∏è  Eliminando anterior...")
            shutil.rmtree(VENV_DIR)
        else:
            print("‚úÖ Usando existente")
            return True
    
    print(f"üîß Creando en: {VENV_DIR}")
    try:
        subprocess.check_call([sys.executable, "-m", "venv", VENV_DIR])
        print("‚úÖ Entorno virtual creado")
        return True
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Error: {e}")
        print("\nüí° Instala python3-venv:")
        print("   sudo apt install python3-venv python3-full")
        return False

def check_system_dependencies():
    print_header("VERIFICANDO DEPENDENCIAS DEL SISTEMA")
    print("‚ÑπÔ∏è  Pygame requiere librer√≠as del sistema\n")
    
    try:
        result = subprocess.run(['which', 'apt'], capture_output=True)
        has_apt = result.returncode == 0
    except:
        has_apt = False
    
    if has_apt:
        print("üîç Sistema Debian/Ubuntu detectado")
        response = input("\n¬øInstalar dependencias del sistema? (s/n): ")
        
        if response.lower() in ['s', 'si', 'y', 'yes']:
            packages = [
                'python3-dev', 'python3-venv', 'python3-full',
                'libsdl2-dev', 'libsdl2-mixer-dev', 'libsdl2-image-dev',
                'libsdl2-ttf-dev', 'libfreetype6-dev', 'build-essential'
            ]
            
            print("\nüì¶ Instalando...")
            try:
                cmd = ['sudo', 'apt', 'install', '-y'] + packages
                subprocess.check_call(cmd)
                print("‚úÖ Dependencias instaladas")
            except:
                print("‚ö†Ô∏è  Algunas dependencias fallaron")
        else:
            print("\n‚ö†Ô∏è  Saltando instalaci√≥n de sistema")
    
    return True

def install_dependencies():
    print_header("INSTALANDO DEPENDENCIAS DE PYTHON")
    
    if not os.path.exists(VENV_PYTHON):
        print("‚ùå Entorno virtual no encontrado")
        return False
    
    print("üîÑ Actualizando pip...")
    try:
        subprocess.check_call([VENV_PYTHON, "-m", "pip", "install", "--upgrade", "pip"],
                            stdout=subprocess.DEVNULL)
        print("‚úÖ pip actualizado\n")
    except:
        print("‚ö†Ô∏è  No se pudo actualizar pip\n")
    
    dependencies = ["pygame", "Pillow", "mutagen", "pyinstaller"]
    
    for dep in dependencies:
        print(f"üì¶ Instalando {dep}...")
        try:
            subprocess.check_call([VENV_PYTHON, "-m", "pip", "install", dep])
            print(f"   ‚úÖ {dep} instalado")
        except:
            print(f"   ‚ùå Error con {dep}")
            if dep == "pygame":
                print("   üí° Instala dependencias de sistema primero")
            return False
    
    print("\n‚úÖ Todas las dependencias instaladas")
    return True

def create_spec_file():
    print_header("CREANDO CONFIGURACI√ìN DE PYINSTALLER")
    
    logo_exists = os.path.exists(os.path.join(SCRIPT_DIR, 'LogoLogin.png'))
    foto_exists = os.path.exists(os.path.join(SCRIPT_DIR, 'emiliaMP3Foto.png'))
    
    datas_list = []
    if logo_exists:
        datas_list.append("('LogoLogin.png', '.')")
    if foto_exists:
        datas_list.append("('emiliaMP3Foto.png', '.')")
    
    # M√≥dulos necesarios
    modulos = [
        'radioBloom.py',
        'config_persistente.py',
        'GestorVentanas.py',
        'PaginaEditarPerfil.py'
    ]
    
    for modulo in modulos:
        if os.path.exists(os.path.join(SCRIPT_DIR, modulo)):
            datas_list.append(f"('{modulo}', '.')")
    
    datas_string = ",\n        ".join(datas_list)
    icon_line = f"icon='LogoLogin.png'" if logo_exists else "icon=None"
    script_dir_safe = repr(SCRIPT_DIR)
    
    spec_content = f"""# -*- mode: python ; coding: utf-8 -*-

block_cipher = None

a = Analysis(
    ['BloomMusic.py'],
    pathex=[{script_dir_safe}],
    binaries=[],
    datas=[
        {datas_string}
    ],
    hiddenimports=[
        'pygame', 'PIL', 'mutagen', 'sqlite3', 'tkinter',
        'config_persistente', 'GestorVentanas', 'PaginaEditarPerfil', 'radioBloom'
    ],
    hookspath=[],
    hooksconfig={{}},
    runtime_hooks=[],
    excludes=[],
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='BloomMusic',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    {icon_line}
)
"""
    
    spec_path = os.path.join(SCRIPT_DIR, "BloomMusic.spec")
    with open(spec_path, "w", encoding='utf-8') as f:
        f.write(spec_content)
    
    print(f"‚úÖ Archivo .spec creado")
    return True

def build_executable():
    print_header("CREANDO EJECUTABLE")
    print("‚öôÔ∏è  Compilando... (varios minutos)\n")
    
    try:
        spec_file = os.path.join(SCRIPT_DIR, "BloomMusic.spec")
        pyinstaller_path = os.path.join(VENV_DIR, "bin", "pyinstaller")
        
        if not os.path.exists(pyinstaller_path):
            print("‚ùå PyInstaller no encontrado")
            return False
        
        subprocess.check_call([pyinstaller_path, spec_file, "--clean"])
        print("\n‚úÖ Ejecutable creado")
        return True
    except subprocess.CalledProcessError as e:
        print(f"\n‚ùå Error: {e}")
        return False

def verify_files():
    print_header("VERIFICANDO ARCHIVOS DEL PROYECTO")
    print(f"üìÇ Buscando en: {SCRIPT_DIR}\n")
    
    required_files = [
        "BloomMusic.py",
        "config_persistente.py",
        "GestorVentanas.py",
        "PaginaEditarPerfil.py",
        "radioBloom.py"
    ]
    
    optional_files = ["LogoLogin.png", "emiliaMP3Foto.png"]
    
    all_ok = True
    
    print("üìã Archivos REQUERIDOS:")
    for file in required_files:
        if os.path.exists(os.path.join(SCRIPT_DIR, file)):
            print(f"  ‚úÖ {file}")
        else:
            print(f"  ‚ùå {file} NO ENCONTRADO")
            all_ok = False
    
    print("\nüìã Archivos OPCIONALES:")
    for file in optional_files:
        if os.path.exists(os.path.join(SCRIPT_DIR, file)):
            print(f"  ‚úÖ {file}")
        else:
            print(f"  ‚ö†Ô∏è  {file} no encontrado")
    
    return all_ok

def create_desktop_entry():
    print_header("CREANDO INTEGRACI√ìN CON EL ESCRITORIO")
    
    exe_path = os.path.join(SCRIPT_DIR, "dist", "BloomMusic")
    logo_path = os.path.join(SCRIPT_DIR, "LogoLogin.png")
    
    if not os.path.exists(logo_path):
        logo_path = ""
    
    desktop_content = f"""[Desktop Entry]
Version=1.0
Type=Application
Name=Bloom Music V2
Comment=Reproductor de m√∫sica con BD persistente
Exec={exe_path}
Icon={logo_path}
Terminal=false
Categories=AudioVideo;Audio;Player;
Keywords=music;audio;player;mp3;
"""
    
    desktop_file = os.path.join(SCRIPT_DIR, "BloomMusic.desktop")
    with open(desktop_file, "w") as f:
        f.write(desktop_content)
    
    os.chmod(desktop_file, 0o755)
    print(f"‚úÖ Archivo .desktop creado")
    print(f"\nüí° Para a√±adirlo al men√∫:")
    print(f"   cp {desktop_file} ~/.local/share/applications/")
    return desktop_file

def create_launcher_script():
    print_header("CREANDO SCRIPT DE LANZAMIENTO")
    
    launcher_content = """#!/bin/bash
# Bloom Music V2 Launcher
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"
exec ./dist/BloomMusic "$@"
"""
    
    launcher_path = os.path.join(SCRIPT_DIR, "bloom_music.sh")
    with open(launcher_path, "w") as f:
        f.write(launcher_content)
    
    os.chmod(launcher_path, 0o755)
    print(f"‚úÖ Script creado: bloom_music.sh")
    return launcher_path

def create_readme():
    print_header("CREANDO DOCUMENTACI√ìN")
    
    readme_content = """# BLOOM MUSIC V2 - Linux (BD Persistente)

## üéµ Nueva Versi√≥n - Caracter√≠sticas

‚úÖ **BD Persistente**: Tu cuenta NO se pierde
‚úÖ **Navegaci√≥n mejorada**: Sin perder datos
‚úÖ **Editar perfil**: Gestiona tu cuenta
‚úÖ **C√≥digo optimizado**: 53% menos l√≠neas

## üöÄ Ejecutar

### Opci√≥n 1: Directo
```bash
./dist/BloomMusic
```

### Opci√≥n 2: Script
```bash
./bloom_music.sh
```

### Opci√≥n 3: Men√∫
```bash
cp BloomMusic.desktop ~/.local/share/applications/
```

## üíæ Base de Datos

Ubicaci√≥n: `~/.config/BloomMusic/database/`

**Beneficios:**
- ‚úÖ NO se pierde al reinstalar
- ‚úÖ Actualiza sin perder datos
- ‚úÖ Protegida en ubicaci√≥n est√°ndar

## üìã Archivos Requeridos

- BloomMusic.py
- config_persistente.py
- GestorVentanas.py
- PaginaEditarPerfil.py
- radioBloom.py

## üîß Dependencias Sistema

```bash
sudo apt install python3-dev python3-venv python3-full \\
  libsdl2-dev libsdl2-mixer-dev build-essential
```

## ‚ú® Nuevas Funciones

- **Editar perfil**: Men√∫ "‚ãØ" ‚Üí "Editar Perfil"
- **8 vistas**: Home, Canciones, Recientes, Crear Playlist, etc.
- **M√∫sica continua**: Sigue sonando entre vistas

## üìö M√°s Info

- RESUMEN_CAMBIOS.md: Qu√© cambi√≥
- INSTRUCCIONES_IMPLEMENTACION.md: Gu√≠a completa

---
**Bloom Music V2** - Con BD Persistente üéµ
"""
    
    readme_path = os.path.join(SCRIPT_DIR, "README_LINUX.md")
    with open(readme_path, "w", encoding="utf-8") as f:
        f.write(readme_content)
    
    print(f"‚úÖ README_LINUX.md creado")

def main():
    print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                          ‚ïë
‚ïë     üéµ BLOOM MUSIC V2 - INSTALADOR LINUX üéµ              ‚ïë
‚ïë                                                          ‚ïë
‚ïë  ‚ú® Con Base de Datos Persistente ‚ú®                     ‚ïë
‚ïë  Compatible con Python 3.13+ (PEP 668)                  ‚ïë
‚ïë                                                          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    
    # Paso 1: Verificar Python
    if not check_python_version():
        input("\nENTER para salir...")
        return
    
    # Paso 2: Verificar venv
    if not check_venv_support():
        input("\nENTER para salir...")
        return
    
    # Paso 3: Verificar archivos
    if not verify_files():
        print("\n‚ùå Faltan archivos necesarios")
        print("\nüí° Copia TODOS estos archivos:")
        print("   ‚Ä¢ BloomMusic.py")
        print("   ‚Ä¢ config_persistente.py")
        print("   ‚Ä¢ GestorVentanas.py")
        print("   ‚Ä¢ PaginaEditarPerfil.py")
        print("   ‚Ä¢ radioBloom.py")
        input("\nENTER para salir...")
        return
    
    # Paso 4: Buscar BD existente
    bd_existente = buscar_bd_existente()
    
    # Paso 5: Dependencias sistema
    check_system_dependencies()
    
    # Paso 6: Crear venv
    if not create_virtual_environment():
        input("\nENTER para salir...")
        return
    
    # Paso 7: Crear docs
    create_readme()
    
    # Paso 8: Preguntar si continuar
    print("\n" + "="*60)
    respuesta = input("¬øInstalar dependencias y crear ejecutable? (s/n): ")
    
    if respuesta.lower() not in ['s', 'si', 'y', 'yes']:
        print("\n‚úÖ Entorno creado, docs listas")
        print("\nüí° Para continuar: python3 setup_bloom_linux.py")
        return
    
    # Paso 9: Instalar deps
    if not install_dependencies():
        print("\n‚ùå Error en dependencias")
        input("\nENTER para salir...")
        return
    
    # Paso 10: Crear .spec
    if not create_spec_file():
        print("\n‚ùå Error en config")
        input("\nENTER para salir...")
        return
    
    # Paso 11: Crear ejecutable
    if not build_executable():
        print("\n‚ùå Error creando ejecutable")
        input("\nENTER para salir...")
        return
    
    # Paso 12: Crear integraciones
    launcher_path = create_launcher_script()
    desktop_file = create_desktop_entry()
    
    # ¬°√âxito!
    print_header("¬°INSTALACI√ìN COMPLETADA!")
    
    exe_path = os.path.join(SCRIPT_DIR, "dist", "BloomMusic")
    
    print("‚úÖ Bloom Music V2 instalado\n")
    print("üìÅ Ejecutable:")
    print(f"   {exe_path}\n")
    
    if os.path.exists(exe_path):
        os.chmod(exe_path, 0o755)
        print("‚úÖ Permisos configurados\n")
    
    print("üìÅ Archivos creados:")
    print(f"   ‚Ä¢ {exe_path}")
    print(f"   ‚Ä¢ {launcher_path}")
    print(f"   ‚Ä¢ {desktop_file}")
    print(f"   ‚Ä¢ {VENV_DIR}/ (entorno virtual)")
    print("   ‚Ä¢ README_LINUX.md")
    
    print("\nüíæ Tu BD estar√° en:")
    print("   ~/.config/BloomMusic/database/\n")
    
    if bd_existente:
        print("üìã Tu BD existente:")
        print("   ‚úÖ Fue detectada")
        print("   ‚úÖ Se importar√° al primer uso")
        print("   ‚úÖ Tu cuenta estar√° disponible\n")
    
    print("üöÄ Para ejecutar:\n")
    print("   Opci√≥n 1: ./dist/BloomMusic")
    print("   Opci√≥n 2: ./bloom_music.sh\n")
    
    print("‚ú® Nuevas funciones:")
    print("   ‚Ä¢ Editar perfil desde la app")
    print("   ‚Ä¢ 8 vistas de navegaci√≥n")
    print("   ‚Ä¢ M√∫sica continua entre vistas")
    print("   ‚Ä¢ BD que NO se pierde\n")
    
    print("=" * 60)
    
    response = input("\n¬øA√±adir al men√∫ de aplicaciones? (s/n): ")
    if response.lower() in ['s', 'si', 'y', 'yes']:
        apps_dir = os.path.expanduser("~/.local/share/applications")
        os.makedirs(apps_dir, exist_ok=True)
        shutil.copy(desktop_file, apps_dir)
        print("\n‚úÖ A√±adido al men√∫")
    
    input("\nENTER para salir...")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n‚ùå Instalaci√≥n cancelada")
        sys.exit(0)
    except Exception as e:
        print(f"\n\n‚ùå Error: {e}")
        print(f"\nüìÇ Directorio: {SCRIPT_DIR}")
        import traceback
        traceback.print_exc()
        input("\nENTER para salir...")
        sys.exit(1)